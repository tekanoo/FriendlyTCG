rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Règles pour les utilisateurs connectés
    match /users/{userId} {
      // Lecture : Autorisé pour tous les utilisateurs connectés (pour les échanges)
      allow read: if request.auth != null;
      // Écriture : Autorisé seulement pour le propriétaire du document
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Règles pour les échanges
    match /trades/{tradeId} {
      // Lecture et écriture : Autorisés pour les participants de l'échange
      allow read, write: if request.auth != null && 
        (request.auth.uid == resource.data.fromUserId || 
         request.auth.uid == resource.data.toUserId);
      // Création : Autorisée pour tout utilisateur connecté
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.fromUserId;
    }
    
    // Règles pour les messages d'échange
    match /trade_messages/{messageId} {
      // Lecture : Autorisée pour les participants de l'échange correspondant
      allow read: if request.auth != null && 
        exists(/databases/$(database)/documents/trades/$(resource.data.tradeId)) &&
        (request.auth.uid == get(/databases/$(database)/documents/trades/$(resource.data.tradeId)).data.fromUserId ||
         request.auth.uid == get(/databases/$(database)/documents/trades/$(resource.data.tradeId)).data.toUserId);
      // Création : Autorisée pour les participants de l'échange
      allow create: if request.auth != null && 
        exists(/databases/$(database)/documents/trades/$(request.resource.data.tradeId)) &&
        (request.auth.uid == get(/databases/$(database)/documents/trades/$(request.resource.data.tradeId)).data.fromUserId ||
         request.auth.uid == get(/databases/$(database)/documents/trades/$(request.resource.data.tradeId)).data.toUserId) &&
        request.auth.uid == request.resource.data.senderId;
    }
    
    // Collection de test pour vérifier la connexion
    match /test/{document} {
      allow read, write: if request.auth != null;
    }

    // ---------------------------
    // Communauté : Posts publics
    // ---------------------------
    match /posts/{postId} {
      // Tous les utilisateurs (même non connectés) peuvent lire les posts
      allow read: if true;

      // Création uniquement pour utilisateur connecté avec contraintes
      allow create: if request.auth != null
        && request.resource.data.authorUid == request.auth.uid
        && request.resource.data.text is string
        && (request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 5000)
        && request.resource.data.createdAt == request.time
        && request.resource.data.likeCount == 0;

      // Mise à jour:
      //  - L'auteur peut (optionnel) éditer le texte (limite longueur) sans toucher aux champs protégés
      //  - OU n'importe quel utilisateur connecté peut mettre à jour likeCount UNIQUEMENT (±1) sans modifier les autres champs
      allow update: if request.auth != null && (
          // Cas 1: auteur édite le texte
          (request.auth.uid == resource.data.authorUid
            && request.resource.data.authorUid == resource.data.authorUid
            && request.resource.data.likeCount == resource.data.likeCount
            && request.resource.data.text is string
            && (request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 5000)
            && request.resource.data.createdAt == resource.data.createdAt
            && request.resource.data.keys().hasOnly(['text','authorUid','authorName','authorPhoto','createdAt','likeCount']))
          ||
          // Cas 2: simple ajustement likeCount (±1) par un utilisateur connecté
          (request.resource.data.authorUid == resource.data.authorUid
            && request.resource.data.text == resource.data.text
            && request.resource.data.authorName == resource.data.authorName
            && request.resource.data.authorPhoto == resource.data.authorPhoto
            && request.resource.data.createdAt == resource.data.createdAt
            && request.resource.data.likeCount is int
            && (request.resource.data.likeCount == resource.data.likeCount + 1 || request.resource.data.likeCount == resource.data.likeCount - 1)
            && request.resource.data.keys().hasOnly(['text','authorUid','authorName','authorPhoto','createdAt','likeCount']) )
        );

      // Suppression uniquement par l'auteur (optionnel)
      allow delete: if request.auth != null && request.auth.uid == resource.data.authorUid;

      // Sous-collection Likes: un doc par utilisateur
      match /likes/{userId} {
        allow read: if true;
        allow create: if request.auth != null && request.auth.uid == userId
          && !exists(/databases/$(database)/documents/posts/$(postId)/likes/$(userId));
        allow delete: if request.auth != null && request.auth.uid == userId;
        allow update: if false; // Pas d'update, juste create/delete
      }

      // Sous-collection Comments
      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null
          && request.resource.data.authorUid == request.auth.uid
          && request.resource.data.text is string
          && (request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 3000)
          && request.resource.data.createdAt == request.time;
        allow update: if false; // édition désactivée pour simplicité
        allow delete: if request.auth != null && request.auth.uid == resource.data.authorUid;
      }
    }

    // ---------------------------
    // Feedback (optionnel) - lecture interdite sauf si propriétaire
    // ---------------------------
    match /feedback/{feedbackId} {
      allow create: if request.auth != null
        && request.resource.data.text is string
        && (request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 5000);
      // Lecture des feedbacks: restreindre à l'auteur (ou désactiver complètement)
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      allow update, delete: if false;
    }

    // ---------------------------
    // Marketplace
    // ---------------------------
    match /marketplace_listings/{listingId} {
      // Lecture publique (toutes les annonces visibles)
      allow read: if true;
      // Création: sellerId doit correspondre à l'utilisateur connecté
      allow create: if request.auth != null
        && request.resource.data.sellerId == request.auth.uid
        && request.resource.data.cardName is string
        && request.resource.data.cardName.size() > 0
        && request.resource.data.priceCents is int
        && request.resource.data.priceCents > 0
        && request.resource.data.status == 'active';
      // Mise à jour: seulement vendeur OU acheteur (si réservé) peut modifier champs autorisés
      allow update: if request.auth != null && (
        // Vendeur peut ajuster prix ou statut (cancel / reserved -> sold via validations) et flags validation
        (request.auth.uid == resource.data.sellerId
          && request.resource.data.sellerId == resource.data.sellerId
          && request.resource.data.cardName == resource.data.cardName
          && request.resource.data.priceCents is int
          && request.resource.data.priceCents > 0
          && request.resource.data.listingType in ['sale','buy']
          && request.resource.data.keys().hasOnly(['sellerId','sellerName','sellerRegion','cardName','priceCents','status','createdAt','updatedAt','soldAt','buyerId','sellerValidated','buyerValidated','listingType']) )
        ||
        // Acheteur (réservé) peut seulement poser son flag de validation
        (resource.data.buyerId != null && request.auth.uid == resource.data.buyerId
          && request.resource.data.buyerValidated in [true, resource.data.buyerValidated]
          && request.resource.data.sellerValidated == resource.data.sellerValidated
          && request.resource.data.priceCents == resource.data.priceCents
          && request.resource.data.sellerId == resource.data.sellerId
          && request.resource.data.cardName == resource.data.cardName
          && request.resource.data.status in ['reserved','sold']
          && request.resource.data.listingType == resource.data.listingType
          && request.resource.data.keys().hasOnly(['sellerId','sellerName','sellerRegion','cardName','priceCents','status','createdAt','updatedAt','soldAt','buyerId','sellerValidated','buyerValidated','listingType']) )
      );
      // Suppression: vendeur uniquement tant que non sold
      allow delete: if request.auth != null && request.auth.uid == resource.data.sellerId && resource.data.status != 'sold';
    }

    match /marketplace_offers/{offerId} {
      allow read: if true; // Offres visibles pour transparence (peut être restreint plus tard)
      allow create: if request.auth != null
        && request.resource.data.buyerId == request.auth.uid
        && request.resource.data.listingId is string
        && request.resource.data.proposedPriceCents is int
        && request.resource.data.status == 'pending';
      // Update: vendeur accepte / refuse; acheteur peut withdraw (pending seulement)
      allow update: if request.auth != null && (
        // Vendeur change statut -> accepted/declined
        (request.auth.uid == get(/databases/$(database)/documents/marketplace_listings/$(resource.data.listingId)).data.sellerId
          && resource.data.status == 'pending'
          && request.resource.data.status in ['accepted','declined']
          && request.resource.data.keys().hasOnly(['listingId','buyerId','buyerName','proposedPriceCents','status','createdAt','updatedAt']))
        ||
        // Acheteur withdraw
        (request.auth.uid == resource.data.buyerId
          && resource.data.status == 'pending'
          && request.resource.data.status == 'withdrawn'
          && request.resource.data.keys().hasOnly(['listingId','buyerId','buyerName','proposedPriceCents','status','createdAt','updatedAt']))
      );
      allow delete: if false; // pas de suppression (historique)
    }

    match /marketplace_messages/{messageId} {
      // Lecture: participants (vendeur + acheteur si réservé) OU vendeur seul avant réservation
      allow read: if request.auth != null && (
        request.auth.uid == get(/databases/$(database)/documents/marketplace_listings/$(resource.data.listingId)).data.sellerId
        || (
          get(/databases/$(database)/documents/marketplace_listings/$(resource.data.listingId)).data.buyerId != null
          && request.auth.uid == get(/databases/$(database)/documents/marketplace_listings/$(resource.data.listingId)).data.buyerId
        )
      );
      // Création: même règle + senderId doit être l'utilisateur
      allow create: if request.auth != null && (
        (
          request.auth.uid == get(/databases/$(database)/documents/marketplace_listings/$(request.resource.data.listingId)).data.sellerId
          || (
            get(/databases/$(database)/documents/marketplace_listings/$(request.resource.data.listingId)).data.buyerId != null
            && request.auth.uid == get(/databases/$(database)/documents/marketplace_listings/$(request.resource.data.listingId)).data.buyerId
          )
        )
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.cipherText is string
        && request.resource.data.timestamp == request.time
      );
      allow update, delete: if false;
    }

    // ---------------------------
    // Conversations marketplace
    // ---------------------------
    match /conversations/{conversationId} {
      // Lecture: participant (basé sur le tableau participants)
      allow read: if request.auth != null &&
        resource.data.participants is list &&
        request.auth.uid in resource.data.participants;
      
      // Création: utilisateur connecté, données valides, et tous les champs requis
      allow create: if request.auth != null && 
        // Accepte un timestamp fourni par le client (plus souple que == request.time)
        request.resource.data.createdAt is timestamp &&
        (request.auth.uid == request.resource.data.sellerId ||
         request.auth.uid == request.resource.data.buyerId) &&
        request.resource.data.listingId is string &&
        request.resource.data.cardName is string &&
        request.resource.data.sellerId is string &&
        request.resource.data.buyerId is string &&
        request.resource.data.sellerName is string &&
        request.resource.data.buyerName is string &&
        request.resource.data.type is string &&
        request.resource.data.status is string &&
        request.resource.data.originalPriceCents is int &&
        request.resource.data.hasUnreadBuyer is bool &&
        request.resource.data.hasUnreadSeller is bool &&
        request.resource.data.participants is list &&
        request.resource.data.participants.size() == 2;
      
      // Mise à jour: tout participant
      allow update: if request.auth != null &&
        resource.data.participants is list &&
        request.auth.uid in resource.data.participants;
      
      allow delete: if false; // pas de suppression
      
      // Messages des conversations
      match /messages/{messageId} {
        // Lecture: participant
        allow read: if request.auth != null &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        
        // Création: participant + senderId cohérent
        allow create: if request.auth != null && 
          request.resource.data.senderId == request.auth.uid &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
          // createdAt peut être un timestamp client; la précision exacte n'est pas critique ici
          request.resource.data.createdAt is timestamp &&
          request.resource.data.content is string;
        
        allow update, delete: if false; // messages immutables
      }
    }
  }
}
